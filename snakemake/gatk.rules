"""
This contains GATK-related processing rules.
"""

rule mark_dups:
  input:
    "{prefix}_merged_aligned_coordinate_sorted.bam"
  output:
    "{prefix}_aligned_coordinate_sorted_dups.bam"
  benchmark:
    "{prefix}_mark_dups_benchmark.txt"
  log:
    "{prefix}_mark_dups.log"
  resources:
    mem_mb = 20000
  shell:
    "TMPDIR={wildcards.prefix}_tmp "
    "MAX_SEQUENCES_FOR_DISK_READ_ENDS_MAP=50000 "
    "MAX_FILE_HANDLES_FOR_READ_ENDS_MAP=20000 "
    "SORTING_COLLECTION_SIZE_RATIO=0.250000 "
    "picard -Xmx20g -Djava.io.tmpdir={wildcards.prefix}_tmp "
    "MarkDuplicates "
    "INPUT={input} OUTPUT={output} "
    "VALIDATION_STRINGENCY=LENIENT METRICS_FILE={wildcards.prefix}_markdups_metrics.txt "
    "2> {log}"

rule sambamba_index_bam:
  input:
    "{prefix}.bam"
  output:
    "{prefix}.bam.bai"
  threads: _get_half_cores
  benchmark:
    "{prefix}_index_benchmark.txt"
  log:
    "{prefix}_index.log"
  shell:
    "sambamba index -t {threads} {input} {output} 2> {log}"

# TODO(julia): figure out how to combine with RNA IndelRealigner rules, very similar

# if this rule is triggered with "chr" mapping to a chromosome in the CHR list, it'll be run
# for that chromosome alone. If "chr" matches any other string, IndelRealigner will run for all
# chromosomes.
rule dna_indel_realigner_target_creator_per_chr:
  input:
    expand("{{prefix}}/{type}_aligned_coordinate_sorted_dups.bam.bai", type=["normal", "tumor"]),
    normal = "{prefix}/normal_aligned_coordinate_sorted_dups.bam",
    tumor = "{prefix}/tumor_aligned_coordinate_sorted_dups.bam"
  output:
    "{prefix}/aligned_coordinate_sorted_dups_indelreal_{chr}.intervals"
  threads: _get_half_cores
  params:
    reference = config["reference"]["genome"]
  benchmark:
    "{prefix}/dna_indel_realigner_target_creator_{chr}_benchmark.txt"
  log:
    "{prefix}/dna_indel_realigner_target_creator_{chr}.log"
  resources:
    mem_mb = 20000
  run:
    intervals_str = _get_intervals_str(wildcards)
    shell("""
      gatk -Xmx20g -T RealignerTargetCreator -R {params.reference} \
      %s \
      -I {input.normal} -I {input.tumor} -o {output} -nt {threads} \
      --filter_reads_with_N_cigar --filter_mismatching_base_and_quals --filter_bases_not_stored \
      2> {log}
    """ % intervals_str)

# if this rule is triggered with "chr" mapping to a chromosome in the CHR list, it'll be run
# for that chromosome alone. If "chr" matches any other string, IndelRealigner will run for all
# chromosomes.
rule dna_indel_realigner_per_chr:
  input:
    expand("{{prefix}}/{type}_aligned_coordinate_sorted_dups.bam.bai", type=["normal", "tumor"]),
    normal = "{prefix}/normal_aligned_coordinate_sorted_dups.bam",
    tumor = "{prefix}/tumor_aligned_coordinate_sorted_dups.bam",
    intervals = "{prefix}/aligned_coordinate_sorted_dups_indelreal_{chr}.intervals"
  output:
    "{prefix}/normal_aligned_coordinate_sorted_dups_indelreal_chr_{chr}.bam",
    "{prefix}/tumor_aligned_coordinate_sorted_dups_indelreal_chr_{chr}.bam"
  params:
    reference = config["reference"]["genome"]
  benchmark:
    "{prefix}/dna_indel_realigner_{chr}_benchmark.txt"
  log:
    "{prefix}/dna_indel_realigner_{chr}.log"
  resources:
    mem_mb = 20000
  # IndelRealigner writes the output to this directory; need to move the files manually after
  run:
    intervals_str = _get_intervals_str(wildcards)
    shell("""
      gatk -Xmx20g -T IndelRealigner -compress 0 -R {params.reference} \
      -I {input.normal} -I {input.tumor} \
      -targetIntervals {input.intervals} %s \
      --filter_reads_with_N_cigar --filter_mismatching_base_and_quals --filter_bases_not_stored \
      --nWayOut _indelreal_chr_{wildcards.chr}.bam \
      2> {log} && \
      mv {{normal,tumor}}_aligned_coordinate_sorted_dups_indelreal_chr_{wildcards.chr}.bam \
      {wildcards.prefix} && \
      mv {{normal,tumor}}_aligned_coordinate_sorted_dups_indelreal_chr_{wildcards.chr}.bai \
      {wildcards.prefix}
    """ % intervals_str)

def _get_dna_indel_realigner_input(wildcards):
  if _PARALLEL_INDEL_REALIGNER:
    return ["%s_aligned_coordinate_sorted_dups_indelreal_chr_%s.bam" % (
        wildcards.prefix, chromosome) for chromosome in CHR]
  else:
    return "%s_aligned_coordinate_sorted_dups_indelreal_chr_ALL.bam" % wildcards.prefix

def _get_bai_from_bam_name(bam_input):
  return 

rule dna_indel_realigner:
  input:
    bam = _get_dna_indel_realigner_input
  output:
    bam = "{prefix}_aligned_coordinate_sorted_dups_indelreal.bam"
  benchmark:
    "{prefix}_indel_realigner_benchmark.txt"
  log:
    "{prefix}_indel_realigner.log"
  run:
    if _PARALLEL_INDEL_REALIGNER:
      shell("sambamba merge {output.bam} {input.bam}")
    else:
      shell("mv {input.bam} {output.bam}")
      input_bai = input.bam.replace(".bam", ".bai")
      output_bai = output.bam.replace(".bam", ".bai")
      # also need to rename the .bai from the .bam
      shell("mv %s %s" % (input_bai, output_bai))

rule base_recalibrator:
  input:
    "{prefix}_aligned_coordinate_sorted_dups_indelreal.bam"
  output:
    "{prefix}_aligned_coordinate_sorted_dups_indelreal_bqsr.table"
  params:
    reference = config["reference"]["genome"],
    known_sites = config["reference"]["dbsnp"]
  threads: _get_half_cores
  benchmark:
    "{prefix}_base_recalibrator_benchmark.txt"
  log:
    "{prefix}_base_recalibrator.log"
  resources:
    mem_mb = 20000
  shell:
    "gatk -Xmx20g -T BaseRecalibrator -nct {threads} -I {input} -R {params.reference} "
    "-knownSites {params.known_sites} -o {output} 2> {log}"

rule bqsr_print_reads:
  input:
    bam = "{prefix}_aligned_coordinate_sorted_dups_indelreal.bam",
    bqsr = "{prefix}_aligned_coordinate_sorted_dups_indelreal_bqsr.table"
  output:
    "{prefix}_aligned_coordinate_sorted_dups_indelreal_bqsr.bam"
  params:
    reference = config["reference"]["genome"]
  threads: _get_half_cores
  benchmark:
    "{prefix}_base_recalibrator_print_reads_benchmark.txt"
  log:
    "{prefix}_base_recalibrator_print_reads.log"
  resources:
    mem_mb = 20000
  shell:
    "gatk -Xmx20g "
    "-T PrintReads -nct {threads} -R {params.reference} -I {input.bam} -BQSR {input.bqsr} "
    "-o {output} 2> {log}"
